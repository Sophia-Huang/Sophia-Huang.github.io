<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[韩语学习第3课|子音(1) ㄱ ㄴ ㄷ ㄹ ㅁ]]></title>
    <url>%2F2019%2F01%2F25%2Fvideo-Learn-Korean-lesson-three%2F</url>
    <content type="text"><![CDATA[子音(19个) ㄱ ㄴ ㄷ ㄹ ㅁ 上一篇：韩语学习第2课|单母音 ㅏㅓㅗㅜㅡㅣㅐㅔㅚㅟ 上堂课复习： 单母音(10个) ㅏ ㅓ ㅗ ㅜ ㅡ ㅣ ㅐ ㅔ ㅚ ㅟ 아 어 오 우 으 이 애 에 외 위 3.1 子音的分类韩语的子音一共19个，依照发音方式的不同分为：平音、送气音、重音三种。在韩语的平音中，有5个子音分别由相对应的气音与重音。 平音 ㄱ kǎ ㄴ nǎ ㄷ tǎ ㄹ lǎ ㅁ mǎ ㅂ pǎ ㅅ ㅇ ㅈ cǎ 气音 ㅋ kà ㅌ tà ㅍ pà ㅊ cà 重音 ㄲ gà ㄸ dà ㅃ bà ㅆ ㅉ zà 3.2 平音(1)3.2.1 ㄱ与汉语中k发音相似。对应键盘R。가 거 고 구 그 기 개 게 괴 귀 3.2.2 ㄴ与汉语中n发音相似。对应键盘S。나 너 노 누 느 니 내 네 뇌 뉘 3.2.3 ㄷ与汉语中t发音相似。对应键盘E。다 더 도 두 드 디 대 데 되 뒤 3.2.4 ㄹ与汉语中l发音相似。对应键盘F。写法与“己”相似。라 러 로 루 르 리 래 레 뢰 뤼 3.2.5 ㅁ与汉语中m发音相似。对应键盘A。마 머 모 무 므 미 매 메 뫼 뮈 3.3 单词练习 가구 고기 가루 구두 애기 家具 肉 粉末 皮鞋 婴儿 나이 누구 나가다 어디 미리 年纪 谁 出去 哪儿 事先 다리 도로 라디오 나누기 머리 腿 道路 收音机 分享 头 注： 나가다 - 出去，其中다表示动词。 3.4 日常用语 안녕히 가세요! 再见(敬语，不走的人对走的人说) 안녕히 계세요!! 再见(敬语，走的人对不走的人说) 안녕 再见(非敬语) 안녕是“安宁”的意思，가指“走”，连起来表示“请你安宁地走吧”。계同계시다，다表示动词，계시다指“在”，连起来表示“请你安宁地呆在这里吧”。 다음 시간에 만나요! 下节课再见！]]></content>
      <tags>
        <tag>韩语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韩语学习第2课|单母音 ㅏㅓㅗㅜㅡㅣㅐㅔㅚㅟ]]></title>
    <url>%2F2019%2F01%2F25%2Fvideo-Learn-Korean-lesson-two%2F</url>
    <content type="text"><![CDATA[单母音(10个) ㅏ ㅓ ㅗ ㅜ ㅡ ㅣ ㅐ ㅔ ㅚ ㅟ 아 어 오 우 으 이 애 에 외 위 上一篇：韩语学习第1课|什么是韩文？한글은 무엇인가?下一篇：韩语学习第3课|子音(1) 上堂课复习： 韩语是谁发明的？什么时候发明的？发明背景是什么？ 1443年；世宗大王；朝鲜半岛说韩语写汉语(文言分离，庶民多文盲) 韩语的构造 — 子音和母音 子音相当于声母，母音相当于韵母 韩语词汇 70%汉字词，20%固有词20%，10%外来词 韩语的语法特点 主宾谓结构 2.1 母音总表 单母音(10个) ㅏ ㅓ ㅗ ㅜ ㅡ ㅣ ㅐ ㅔ ㅚ ㅟ 复合母音(11个) ㅑ ㅕ ㅛ ㅠ ㅒ ㅖ ㅘ ㅙ ㅞ ㅢ 2.2 单母音2.2.1 ㅏ与汉语韵母a相似，但位置较汉语音稍微靠后。先写|再写-，写在方框右半边。对应键盘K。 2.2.2 ㅓ与汉语韵母o相似，介于o与e中间，有点轻的o，\wo\。对应键盘J。 2.2.3 ㅗ与ㅓ有点像，有点重的o，\wo:\。对应键盘H。 2.2.4 ㅜ与汉语韵母u相似。对应键盘N。 2.2.5 ㅡ有点像牙齿咬住嘴咧开发“饿”的音。对应键盘M。 2.2.6 ㅣ与汉语韵母i相似。对应键盘L。 2.2.7 ㅐai，与音标“ae”相似。对应键盘O。 2.2.8 ㅔoi，与ㅔ发音相似，现实中难以区别。书写时左边的|稍微比右边的|短一些会更为美观。对应键盘P。 2.2.9 ㅚo:i，有点像\we\，韩语中“为什么”的发音。对应键盘HL。 2.2.10 ㅟui，有点像\wi:\。对应键盘NL。 2.3 单母音的书写 母音可以单独发音，子音只能搭配母音发音。母音书写的时候需要加子音“ㅇ”，此时“ㅇ”不发音，只发母音的音，“ㅇ”起装饰作用。 ㅏ ㅓ ㅗ ㅜ ㅡ ㅣ ㅐ ㅔ ㅚ ㅟ 아 어 오 우 으 이 애 에 외 위 2.4 读音练习2.4.1 读音对比 아-어 오-우 어-이 이-아 애-에 외-위 으-이 위-에 외-이 으-에 2.4.2 单词练习 아이 오이 이 아우 위 孩子 黄瓜 牙 弟弟 胃 注： 아우 - 弟弟(七八十岁的老年人对弟弟的敬称) 2.5 日常用语 안녕하세요! 您好(敬语，对长辈、老师、第一次见面的人) 안녕! 你好或再见(非敬语，对朋友、亲密的人、比自己小的人) 안녕是“安宁”的意思，하세요是敬语“请”，连起来表示“请你安宁吧，请你平安吧”。 다음 시간에 만나요! 下节课再见！]]></content>
      <tags>
        <tag>韩语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2019年]]></title>
    <url>%2F2019%2F01%2F01%2Fmy-2019%2F</url>
    <content type="text"><![CDATA[私密文档，请输入密码。 Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>归档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习进阶之路1.1|深度学习的介绍]]></title>
    <url>%2F2018%2F11%2F14%2Fintroduction-to-deep-learning-1%2F</url>
    <content type="text"><![CDATA[本文主要讲述深度学习的基本概念，依托于台湾大学李宏毅教授《一天搞懂深度学习》的逻辑框架。本篇是此系列的第一篇，对深度学习进行简单的介绍。 全部章节：深度学习的介绍训练深度学习网络的一些小技巧各种神经网络介绍深度学习的应用与展望 1 深度学习的介绍1.1 深度学习简介1.1.1 深度学习的常见应用 语音识别 图像识别 下围棋(Alpha Go) 对话系统 1.1.2 深度学习的目标机器学习的目标在于，寻找一个函数$f$，将输入数据映射到输出数据。例如：语音识别将一段音频的输入映射到对应的文字输出；图像识别将一个图片的输入映射到对应的类别输出；围棋系统将历史的对弈数据输入映射到下一步棋决策的输出；对话系统将上一句文本内容的输入映射到系统回答的输出。 而深度学习的目标在于，寻找一个框架，即一系列的函数模型$f_i$，利用训练数据进行拟合，再根据训练效果从中挑选出最优的模型。 1.1.3 深度学习的三个步骤 定义一组函数 模型和数据的拟合 选择最优函数 1.1.4 定义一组函数：神经网络 1. 神经网络的基本结构：神经元 人脑的一个神经元通常具有多个树突，用于接收传入的信息；这些树突连接着一条轴突，轴突尾端有许多轴突末梢，与其他多个神经元之间产生连接，从而传递信息。这个连接位置在生物学上称为突触。其行状结构如下： 类似的，神经元模型是一个包含输入、输出和计算功能的模型。其输入可以类比为生物神经元的树突，输出可以类比为生物神经元的轴突，计算则可以类比为细胞核。 下图是一个典型的神经元模型：包括3个输入，1个输出，两个计算功能。 当确定输入、权重、偏差的值以及激活函数的形式后，我们可以通过如上计算图计算出输出a。一个简单的例子如下： 2. 神经网络的概念 将不同的神经元连接起来形成的网络结构就是神经网络。需要注意的是，每个神经网络都可能拥有不同的权重和偏差值，且不同的连接方式也会导致不同的网络结构。权重和偏差都是神经网络的参数$\theta$。 3. 一种最简单的神经网络：完全连接前馈神经网络 前馈神经网络是一种最简单的神经网络，各神经元分层排列。每个神经元只与前一层的神经元相连。接收前一层的输出，并输出给下一层．各层间没有反馈。完全连接前馈神经网络指的是各层神经元之间是全连接的。下图是一个简单的例子： 4. 层的性质 输入层和输出层通常只有一个，但隐含层可以有很多个。隐含层的个数体现了深度学习的“深度”。 TODO：ImageNet网络层深度介绍 对于分类问题，我们需要将输出层的输出映射到标签类别上。常见的一个做法是使用softmax函数作为输出层。它的基本原理是利用指数函数$e^x$，输出一个列表，保证所有数属于[0, 1]且和为1，从而表示该对象属于各个类别的概率。最后，我们选择概率数值最大的类别作为我们的预测标签。 5. 一个简单例子：手写数字识别 MNIST是深度学习入门的一个经典数据集，kaggle上提供了一个基于此数据集的训练项目Digit Recognizer。MNIST数据集主要是由一些手写数字图片所代表的像素值和图片相应的标签组成。图片一共有十类，分别对应0~9这10个阿拉伯数字。我们的目标是根据训练集中已有的图片像素属性和标签，对测试集中的图片样本的标签进行预测。下图是MNIST数据集中一个图片样本：一种可行的方法是，将$(28 \times 28)$个像素值矩阵拉长成一个$(784 \times 1)$维列向量作为输入层，经过一些隐含层后，与一个softmax输出层相连，输出一个$(10 \times 1)$的列向量，其中每个数值代表了该样本属于0~9中各个数字标签的概率。我们根据训练集中的真实标签反向求出各层网络各个神经元的最优参数$\theta$，并将训练得的网络模型应用在测试集上得出预测标签。 1.1.5 模型和数据的拟合：以MNIST为例1. 训练数据 图片的像素值矩阵与每张图片对应的标签。 2. 学习目标 对于训练数据，我们希望每个样本通过神经网络模型得出的概率列表中，真实标签拥有最大的概率值。也就是说，对于真实标签为3的样本，我们希望通过softmax得出的概率列表尽可能地接近$[0, 0, 1, 0, \dots]$。 我们将通过神经网络输出的概率向量与最优概率向量之间的差别定义为损失$l$。将所有样本的损失加和得总损失$L=\sum\limits_{k=1}^nl_k$，我们的目标为：找到一个函数，使得总损失$L$最小，也即找到一组参数$\theta$使得总损失函数$L$最小。 TODO: 损失函数的选择 1.1.6 选择最优函数1. 概述 其实我们总能列举所有的值，暴力搜索出最好的一组参数$\theta=\{w_1, w_2, \dots, b_1, b_2, \dots \}$。但是这种方法的效率极为低下，对于一个输入和输出均有1000个神经元的全连接网络层，我们就有$10^6$个参数需要拟合。因而在深度神经网络中，暴力搜索几乎是不可能的。 由于损失函数是我们自己定义的，我们总可以将其设置为凸函数或者近似凸函数，于是便可以利用运筹学的知识，提高我们的搜索效率，更快地找到全局最优解，或者退而求其次地找到可行且效果接近全局最优解的局部最优解。 梯度下降是神经网络模型训练中最常用的一种优化算法。 2. 梯度下降法 首先，选择权重矩阵$W$的初始值。我们直接采用随机定义，或者RBM预训练。 每次迭代的过程中，我们首先计算出当前状态的梯度，然后从当前状态向负梯度方向移动一个步长单位，达到新的状态。 W_{n+1} \leftarrow W_n - \eta \nabla L(W)直到当前梯度接近于0时，我们认为找到了一个局部最优解，并停止训练。 选取负梯度方向是因为这是梯度下降最快的方向，也即损失函数下降最快的方向。步长即“学习率”，是我们需要事先给定的超参数。学习率太小会导致训练过慢，学习率太高则可能越过最低点而导致更高的损失值。学习率可能是神经网络训练中最重要的超参数设定之一，在调参过程中，我们总是最先确定学习率的值，再确定其他参数。我们既可以选择常数学习率，也可以随着迭代次数的增加逐渐减小学习率，常用的做法有$1/\sqrt{k+1}, 1/\lVert W\rVert ^2$等。 TODO：梯度下降法介绍 以上算法中最消耗计算资源的便是每一次迭代中的求梯度过程。我们自然可以通过极限$\lim\limits_{h \to 0}[f(x+h)-f(x-h)]/2h$来近似求梯度。但是，当网络非常复杂、参数非常多时，每迭代一次都要重新计算非常多次损失函数的梯度，导致计算十分缓慢。一种比较好的改进方法是利用链式法则，用反向传播法求梯度。 3. 反向传播法 下面是cs231n关于理解反向传播法的一个小例子。具体笔记见链接。 1.2 为什么使用深层网络？首先，不是更多的参数就意味着更好的性能，一味地增加网络层数可能会导致更严重的过拟合，反而降低了泛化性能。而参数数量相同的情况下，更瘦更深的网络总是比浅而广的网络效果更好。因为使用诸如ReLU等非线性单元的神经网络在数学上相当于一个分片线性函数，线性区域越多，神经网络的非线性性越强，就有可能取得更好的效果。这就像折纸，越深的网络将纸对折越多次，得到的线性区域也越多。这也是为什么我们称之为“深度学习”而非“广度学习”。[参考链接1] [参考链接2] TODO：模块化 1.3 深度学习简单实战1. 定义一组函数 12345678910111213141516# 建立模型print('#################### Define Model ##########################')model = Sequential()model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu', input_shape=(28, 28, 1)))model.add(Conv2D(filters=32, kernel_size=(5, 5), activation='relu'))model.add(MaxPool2D(pool_size=(2, 2)))model.add(Dropout(0.25))model.add(Conv2D(filters=64, kernel_size=(3, 3), activation='relu'))model.add(Conv2D(filters=64, kernel_size=(3, 3), activation='relu'))model.add(MaxPool2D(pool_size=(2, 2), strides=(2, 2)))model.add(Dropout(0.25))model.add(Flatten())model.add(Dense(256, activation="relu"))model.add(Dropout(0.5))model.add(Dense(10, activation="softmax"))model.summary() 2. 模型和数据的拟合 1loss='categorical_crossentropy' 3. 选择最优函数 12345# 配置模型optimizer = RMSprop(lr=0.001, rho=0.9, epsilon=1e-8, decay=0)model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])# 拟合模型：找到最优参数history = model.fit(x_train, y_train, batch_size=batch_size, epochs=nb_epochs, validation_data=(x_val, y_val), callbacks=[checkpoint], verbose=2) TODO：MNIST手写识别]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第140题|快速幂 [中等]]]></title>
    <url>%2F2018%2F10%2F25%2FLintCode-0140-fast-power%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述计算$a^n \% b$，其中$a$，$b$和$n$都是32位的非负整数。样例例如 $2^{31} \% 3 = 2$例如 $100^{1000} \% 1000 = 0$挑战$O(\log{n})$原题链接 2. 解题思路3. 参考代码1234567891011121314151617class Solution: """ @param a: A 32bit integer @param b: A 32bit integer @param n: A 32bit integer @return: An integer """ def fastPower(self, a, b, n): if n == 0: return 1 % b ans = 1 while n &gt; 0: if n % 2 == 1: ans = ans * a % b a = a * a % b n = n // 2 return ans % b]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第371题|用递归打印数字 [中等]]]></title>
    <url>%2F2018%2F10%2F25%2FLintCode-0371-print-numbers-by-recursion%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述用递归的方法找到从1到最大的N位整数。样例给出 N = 1, 返回 [1,2,3,4,5,6,7,8,9].给出 N = 2, 返回 [1,2,3,4,5,6,7,8,9,10,11,...,99].挑战用递归完成，而非循环的方式。原题链接 2. 解题思路每次调用递归获取1到最大的N-1位整数，并添加$[10^{n-1},10^n)$这一区间的数。 3. 参考代码1234567891011121314class Solution: """ @param n: An integer @return: An array storing 1 to the largest number with n digits. """ def numbersByRecursion(self, n): if n == 0: return [] if n == 1: return list(range(1,10)) else: old_arr = self.numbersByRecursion(n-1) add_arr = list(range(10**(n-1),10**n)) return old_arr + add_arr]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第245题|子树 [中等]]]></title>
    <url>%2F2018%2F10%2F25%2FLintCode-0245-subtree%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述有两个不同大小的二叉树： T1 有上百万的节点； T2有好几百的节点。请设计一种算法，判定 T2 是否为 T1的子树。样例下面的例子中 T2 是 T1 的子树：T1 = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T2 =​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4下面的例子中 T2 不是 T1 的子树：T1 = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T2 =​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4原题链接 2. 解题思路思路1由于前序遍历和中序遍历可以唯一确定一棵树，因而我们可以先计算两棵树的前序遍历序列P1、P2，若P2不在P1内，返回False；否则，计算两棵树的中序遍历I1、I2，若I2不在I1内，返回False，否则返回True。 思路2使用递归，首先判断T2是否与T1是相同树，若是，返回True；否则，递归判断T2是否为T1左子树或右子树的子树。 3. 参考代码123456789101112131415161718192021222324252627282930313233"""Definition of TreeNode:class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, None"""class Solution: """ @param T1: The roots of binary tree T1. @param T2: The roots of binary tree T2. @return: True if T2 is a subtree of T1, or false. """ def isSubtree(self, T1, T2): if T1 is not None and T2 is None: return True elif T1 is None and T2 is not None: return False elif self.isSameTree(T1,T2): return True else: return self.isSubtree(T1.left, T2) or self.isSubtree(T1.right, T2) def isSameTree(self, T1, T2): if T1 is None and T2 is None: return True elif (T1 is None and T2 is not None) or (T1 is not None and T2 is None): return False elif T1.val != T2.val: return False else: return self.isSameTree(T1.left, T2.left) and self.isSameTree(T1.right, T2.right)]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第174题|删除链表中倒数第n个节点 [简单]]]></title>
    <url>%2F2018%2F10%2F09%2FLintCode-0174-remove-nth-node-from-end-of-list%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述给定一个链表，删除链表中倒数第n个节点，返回链表的头节点。链表中的节点个数大于等于n样例给出链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null和 n = 2.删除倒数第二个节点之后，这个链表将变成1-&gt;2-&gt;3-&gt;5-&gt;null.挑战O(n)时间复杂度原题链接 2. 解题思路使用两个指针，其中一个指针先沿着链表走n步，另一个指针从head后退一步，于是两者间差n+1步。直到head走至null时，tmp指向该删节点的前一个节点，令tmp.next = tmp.next.next，即删除了该删节点。将tmp节点从head后退一步的原因是应对出现该删节点位置恰为队首，tmp向前n+1步需要指向空的情况。 3. 参考代码123456789101112131415161718192021222324"""Definition of ListNodeclass ListNode(object): def __init__(self, val, next=None): self.val = val self.next = next"""class Solution: """ @param head: The first node of linked list. @param n: An integer @return: The head of linked list. """ def removeNthFromEnd(self, head, n): res = ListNode(0, next=head) tmp = res for i in range(n): head = head.next while(head is not None): head = head.next tmp = tmp.next tmp.next = tmp.next.next return res.next]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convolutional Neural Networks for Visual Recognition|李飞飞]]></title>
    <url>%2F2018%2F09%2F28%2Fvideo-cs231n-%E6%9D%8E%E9%A3%9E%E9%A3%9E%2F</url>
    <content type="text"><![CDATA[Lecture 1: Course Introduction [slice]1.1 Computer vision overview Related Courses @ Stanford CS131: Undergraduate introductory class cs224n: intersection of deep learning and natural language processing cs231a: more emcompassing cs231n: algorithms and applications, CNN 1.2 Historical context if object recognition is too hard, do object segmentation firstly. SIFT &amp; object recognition: use critical features to represent the whole object, and caculate two objects’ similarity. PASCAL Visual Object Challenge 1.3 Course logistics Lecture 2: Image Classification2.1 The data-driven approachThe Problem: Semantic Gap像素值构成的数值矩阵与标签语义间的差别。稍微移动一下相机，标签不变，但像素值矩阵变化十分巨大，要求算法具有鲁棒性。 解决方法1：基于规则计算图形边缘，并对每部分进行分类，如三条线交于一点可能是猫耳朵。123def classify_image(image): return class_label 存在问题： 容易出错 难以迁移到其他学习，例如狗、卡车等。 解决方法2：数据驱动(Data-Driven Approach) Collect a dataset of images and labels Use Machine Learning to train a classifier Evaluate the classifier on new images1234567def train(images, labels): # Machine learning return modeldef predict(model, test_images): # Use model to predict labels return test_labels First classifier: Nearest Neighbour使用训练集中最像的image的label作为test集中需要预测的image的label使用L1距离表示两张图片的相似度 Example Dataset: CIFAR10 源代码：Complexity: train O(1), predict O(N) Problem 1: 我们希望训练过程相对复杂而预测过程比较简单解决办法：使用CNN等其他算法 problem 2: 由于离群点或噪声的存在，预测可能不准解决办法：使用KNN(平滑边界) 2.2 K-nearest neighbor [notes]L1距离和L2距离的差别：L1距离取决于坐标系，而L2距离与坐标系无关。如果特征向量有明确的意义，用L1距离或许会更好；若特征向量只是某个空间中的一个通用向量，我们并不知道其意义，用L2距离或许会更好。交叉验证更适用于较小的数据集，在深度学习中不常用。 KNN问题： 不适用于图像处理 维度灾难(the curse of dimensionality)：随着特征维度增加，训练成本指数级增加。(维度高时，若想准确分类，需要更多的样本，否则样本在空间内分布稀疏) 2.3 Linear classification I [notes]问题1：对于某一种类别只会学习出单一的平均的模板，而对于图像而言，训练集常出现的是某个标准图像的各种变体，例如车的正面侧面，使得训练出的模板W变得似乎四不像。解决方法：使用神经网络或者其他更为复杂的模型，不局限于仅仅学习一个模板(model)。问题2：低维空间的线性不可分问题 Lecture 3: Loss Functions and Optimization3.1 Linear classification II通过损失函数Loss Function来确定较好的$W$。 Given an example $(x_i,y_i)$, where $x_i$ is the image and $y_i$ is the (integer) label. The scores vector is $s=f(x_i,W)$Loss over the dataset is a sum of loss over examples: W=argmin L=argmin \frac{1}{N}\sum L_i(f(x_i,W),y_i)The SVM loss has the form:\begin{align}L_i &amp;= \sum\limits_{j\neq y_i} \begin{cases} 0, &amp;\text{if $s_{y_i}\geq s_j+1$}\\ s_j-s_{y_i}+1, &amp;\text{otherwise} \end{cases}\\ &amp;=\sum\limits_{j\neq y_i}max(0,s_j-s_{y_i}+1)\end{align} ——"Hinge loss" 对于所有错误的分类，比较正确分类的分数和错误分类的分数，如果正确分类的分数比错误分类的分数高出某个安全边界(此处设为1)，则损失设为0，否则设为两者之差。threshold为1类似于SVM中的支持向量，无论设为多少，都是同时增大或减少。Example: Q1: What happens to loss if car scores change a bit?A1: 由于car的分数比其他类别高出许多，所以即使图像稍微变动一点，Loss Function依然会是0。因而这个模型比较具有鲁棒性。 Q2: what is the min/max possible loss?A2: 根据Hinge loss，最大可能值为0，最小可能值为负无穷。 Q3: At initialization W is small so all s ≈ 0. What is the loss?A3: $L_i = \sum\limits_{j\neq y_i}1=N-1$ Q4: What if the sum was over all classes? (including j = y_i)A4: 结果+1 Q5: What if we used mean instead of sum?A5: 损失函数缩小常数倍，结果不影响。 Q6: What if we used $L_i=\sum\limits_{j\neq y_i}max(0,s_j-s_{y_i}+1)^2$?A6: 损失函数进行了非线性变换，结果会产生影响。 123456def L_i_vectorized(x,y,W): scores = W.dot(x) margins = np.maximum(0, scores - scores[y] + 1) margins[y] = 0 loss_i = np.sum(margins) return loss_i Q7: Suppose that we found a W such that L = 0. Is this W unique?A7: Not unique. For any constant c$\neq$0,cW also satisfies. 避免过拟合，加入正则项，选择更简单的W。L1偏向于更稀疏，L2偏向于所有数字更小。 3.2 Higher-level representations, image featuresSoftmax Classifier(Multinomial Logistic Regression)对于SVM模型，我们并没有指定scores的内在含义，而对于Softmax loss，scores表示概率。我们希望真实标签的概率越大且接近1。Example: Q1: What is the min/max possible loss L_i?A1: 最大0，最小负无穷。 Q2: Usually at initialization W is small ao all s ≈ 0. What is the loss?A2: $\log{N}$ SVM &amp; Softmax对比： Conclusion: 3.3 Optimization, stochastic gradient descentStrategy 1. random search Strategy 2. Follow the slope(gradient descent) finite difference: Calculus Problem: 当N，即样本量很大时，每次迭代每个变量的梯度会使得计算十分复杂。此时经常采用随机梯度下降法。Stochastic Gradient Descent其中256是一个minibatch，总是使用形如$2^n$作为minibatch。 [并没有听懂] Lecture 4: Introduction to Neural Networks4.1 Backpropagationcomputational graphs express a function using a computational graph use Backpropagation to compute gradient(recursively use the chain rule) 4.2 Multi-layer PerceptronsExamples:当某个较为复杂的部分可以计算梯度时，可以选择用一个节点去替代它，如上图例二中的sigmoid函数。 add: 按本身值分配max: 分配给最大值，其余节点为0multiply: 按另一个节点的值分配给当前节点 Always check: The gradient with respect to a variable should have the same shape as the variable. Codes: 4.3 The neural viewpointCode: 神经网络的工作原理: Activation functions: Lecture 5: Convolutional Neural Networks5.1 History CNN需要训练卷积层，卷积层能够更好地保留输入的空间结构 5.2 Convolution and poolingFully Connected Layer: Convolution Layer将卷积核和原层对应部分做点乘再相加。[32323]x[553] —&gt; [28281]使用不同的卷积核，可以得到多个activation maps Example: output size: (N - F) / stride + 1Common to zero pad the border: (N + pad_N * 2 - F) / stride + 1零填充的原因：保证全尺寸输出 —&gt; stride=1时，填充(F-1)/2 Examples:Input volume: [32323]filters: 10 [553] with stride1, pad 2Q1: What’s the output volume size?output size = (32+22-5)/1+1=32so, output volume size = 323210Q2: Number of parameters in this layer?Each filter has 553+1=76 params, one for bias,so total number of parameters is 7610=760 summary: Example: CONV layers in Torch and Caffe 5.3 ConvNets outside visionPooling: 池化目的：降维，减少参数数量；深度不减example: [22422464] —&gt; [11211264]max polling 可以表示当前卷积核所在位置的最大受激活程度一般不在池化层填0，因为池化层一般只做降采样最后添加一个全连接层和朴素的神经网络相连 demo: http://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html Lecture 6: Training Neural Networks, part I6.1 Activation functions 1. 画computional graphs函数：$f=Wx$hinge loss: $L_i=\sum\limits_{j\neq y_i}max(0,s_j-s_{y_i}+1)penalty: $R(W)$2. 关于$f$Neural NetworksLinear score function: $f=Wx$2-layer Neural Network: $f=W_2max(0,W_1x)$包含若干个线性层，层与层之间通过非线性函数连接实现层的堆叠3. 一种特殊的神经网络—CNN使用卷积层保持输入的空间结构，卷积层是一个权重滤波器，每个权重输出一个激活图，重复产生多个激活图4. 通过优化来选择权重W向负梯度方向更新 mini-batch SGDLoop:Sample a batch of dataForward prop it through the graph (network), get lossBackprop to calculate the gradientsUpdate the parameters using the gradient5. 训练神经网络 One time setupactivation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamicsbabysitting the learning process, parameter updates, hyperparameter optimization Evaluationmodel ensembles 6.1.1 Sigmoid将数字压缩到(0,1)问题： 当X是很大的正数或很大的负数时，值会很接近1或0，此时更新梯度变化很小，导致梯度消失 Sigmoid函数的输出不是零中心的，若初始X全为正，梯度也会全为正，这样梯度只会朝向一三象限。 exp()计算代价较高 6.1.2 tanh将数字压缩到[-1,1]优点：零中心缺点：当X是很大的正数或很大的负数时，值会很接近1或0，此时更新梯度变化很小，导致梯度消失 6.1.2 ReLU$f(x)=max(0,x)$优点：在正轴上不会饱和；计算快；收敛地更快；更具备生物合理性(实证检验)缺点：不是零中心，对于负半轴会出现梯度消失于是人们总喜欢用一些较小的正偏置项来初始化ReLU 6.1.3 Leaky ReLU$f(x)=max(0.01x,x)$存在负斜率，在负半轴结果也较好，不会存在梯度消失情况 6.1.4 PReLU(Parametric)$f(x)=max(\alpha x,x)$将$\alpha$设置为一个超参数，通过学习得到，增加了灵活性 6.1.5 Exponential Linear Units(ELU)$f(x) = \begin{cases} 0, &amp;\text{if $x&gt;0$}\\ \alpha (exp(x)-1), &amp;\text{if $x\leq 0$} \end{cases}$使得均值更接近于0，但是使得负半轴的非系统偏差更容易被保留缺点：exp()计算复杂 6.1.6 Maxout “Neuron”$f(x)=max(x_1^Tx+b_1,x_2^Tx+b_2)$问题：参数个数加倍 TLDR: In practice: Use ReLU. Be careful with your learning rates Try out Leaky ReLU / Maxout / ELU Try out tanh but don’t expect much Don’t use sigmoid 6.2 Data Preprocessing对数据-样本均值，变成零中心数据，这样在第一层输入解决了零均值问题，然而在之后的层中，非零均值的问题更加严重了，所以还是没有解决sigmiod的问题。 6.3 Weight InitializationFirst idea: W=np.random.randn(fan_in,fan_out)*0.01每一层均值基本为0，方差越来越小问题：最后所有激活值都变成了0 Second Idea: np.random.randn(fan_in,fan_out)*1.0 如果改变初始化比例的大小，将0.01改成1.0，则W中的数总是过大，导致模型总是处于饱和状态(趋于+1/-1)，从而使得所有的梯度趋于0而不再更新 Third Idea: “Xavier initialization”W=np.random.randn(fan_in,fan_out)/np.sqrt(fan_in)即单位高斯权值问题：如果使用ReLU，由于将一半的数调整为了0，方差也减小了一半，于是数据又会趋向于0 Fourth Idea: note additional /2W=np.random.randn(fan_in,fan_out)/np.sqrt(fan_in/2) 6.4 batch normalization对每层输入的X做归一化目的：为了避免饱和问题：是否必要？解决：控制饱和程度，在归一化之后，有时通过缩放恢复原函数并做一个小的扰动 好处：改善了梯度流，更加robust 6.5 Babysitting the Learning Process Preprocess the data: zero-centered/normalized choose the architecture: hyperparameters of hidden layer neurons initialize the network, make sure the loss is reasonable(sanity check): 当权重很小，分布很分散时，归一化指数分类器的损失将是$-\log 1/N$ 加入正则项 从小的trainset开始训练，测试模型正确性，去掉正则项，查看权重是否逐渐降为0，准确度逐渐升至1 加入小的正则项，确定learning rate [1e-5,1e-3] 6.6 Hyperparameter Optimizationcross-validation strategyrandom search vs grid search好的learning rate 应该类似于loss先急剧下降，再缓慢下降 Lecture 7: Training Neural Networks, part IIRecall:Weight Initialization: 权重过大则爆炸式增长，权重过小则梯度消失，使用Xaiver对于越深的网络，权重初始化越重要，因为后续的过程中会不断的乘以那些矩阵归一化: 使得数据对参数扰动的变化没有那么明显，比较robust 7.1 Fancier optimization7.1.1: SGD每次向负梯度方向更新$x_{t+1}=x_t-\alpha *\nabla f(x_t)$123while True: dx = compute_gradient(x) x += learning_rate * dx Problem 1: 损失函数在某些方向非常敏感，而在某些方向天然地不敏感 Problem 2: if the loss function has a local minima or saddle point, since there’s zero gradient, gradient descent gets stuck对于低维情况，似乎local minima问题更严重，但对于高维情况，saddle point相对来说更常见 Problem 3: our gradients come from minibatches so they can be noisy. 当前点对梯度的估计由于参数的随机性等包含了较大的噪声 7.1.2: SGD+Momentum想法类似于一个小球滚落，当经过局部最优点或者鞍点的时候，由于速度为0，则会停止在当前点，但如果给了一个速度，可能能越过局部最小点，鞍点处更容易突破；同时，由于保留了上次的速度方向，曲折回合的更新趋势会有所抵消，使得梯度能更快地收敛到最优解$v_{t+1}=\rho v_t+\nabla f(x_t)$$x_{t+1}=x_t-\alpha v_{t+1}$12345vx = 0while True: dx = compute_gradient(x) vx = rho * vx + dx x += learning_rate * dx 7.1.3 Nesterov$v_{t+1}=\rho v_t-\alpha\nabla f(x_t+\rho v_t)$$x_{t+1}=x_t + v_{t+1}$$\Rightarrow$$v_{t+1}=\rho v_t-\alpha\nabla f(\tilde{x}_t)$$\tilde{x}_{t+1}=\tilde{x}_t-\rho v_t+(1+\rho)v_{t+1}=\tilde{x}_t+v_{t+1}+\rho(v_{t+1}-v_t)$12345vx = 0while True: dx = compute_gradient(x) vx = rho * vx + dx x += learning_rate * dx 7.1.4 AdaGrad12345grad_squared = 0while True: dx = compute_gradient(x) grad_squared += dx * dx x -= learning_rate * dx / (np.sqrt(grad_squared) + 1e-7) 对于小梯度，除的数也较小，使得学习速率相当于变大；反之，对于大梯度，除的数也较大，使得学习速率相当于变小。Problem: 随着时间增长，grad_squared会逐渐累积，使得最后步长会越来越小，接近于0，在凸函数的情况下表现很好，非凸问题会困于局部最优点 7.1.5 RMDProp12345grad_squared = 0while True: dx = compute_gradient(x) grad_squared = decay_rate &amp; grad_squared + (1 - decay_rate) * dx * dx x -= learning_rate * dx / (np.sqrt(grad_squared) + 1e-7) 梯度平方按照一定比例下降，好处在于步长最后趋近于0被修正了，坏处在于训练会越来越慢 7.1.6: Adam(almost)将以上动量和除平方方法结合起来1234567first_moment = 0second_moment = 0while True: dx = compute_gradient(x) first_moment = beta1 * first_moment + (1 - beta1) * dx # Momentum second_moment = beta2 * second_moment + (1 - beta2) * dx * dx # AdaGrad/RMSProp x -= learning_rate * first_moment / (np.sqrt(second_moment) + 1e-7) Problem: 第一步时second_moment仍然接近0，处以其根号，得很大的值，即开始时步长非常大 7.1.7: Adam(full form)123456789first_moment = 0second_moment = 0for t in range(num_iterations): dx = compute_gradient(x) first_moment = beta1 * first_moment + (1 - beta1) * dx # Momentum second_moment = beta2 * second_moment + (1 - beta2) * dx * dx # AdaGrad/RMSProp first_unbias = first_moment / (1 - beta ** t) # Bias correction second_unbias = second_moment / (1 - beta2 ** t) # Bias correction x -= learning_rate * first_unbias / (np.sqrt(second_unbias) + 1e-7) # AdaGrad/RMSProp Adam 效果总是非常好，总是首选使用。默认设置beta1=0.9, beta2=0.999, learning_rate=1e-3 or 5e-4 选择一个好的learning ratewe can let learning rate decay over timeexponential decay: $\alpha=\alpha_0e^{-kt}$1/t decay: $\alpha = \alpha_0/(1+kt)$ 7.1.8 Newton method$\theta^*=\theta_0-H^{-1}\nabla_{\theta}J(\theta_0)$使用二阶逼近，没有使用learning_rate，现实中可能使用learning_rateProblem: 需要求Hessian matrix，对于深度学习有些不切实际Quasi-Newton methods: 不求矩阵的逆，用低阶逼近 7.2 Model EnsemblesIdea 1: 独立学习多个学习器，最后组合到一起，例如求平均，最大最小等，可以减少过拟合，达到小但固定的提升 Idea 2: Tips &amp; TricksInstead of using actual parameter vector, keep a moving average of the parameter vector and use thatat test time (Polyak averaging)123456while True: data_batch = dataset.sample_data_batch() loss = network.forward(data_batch) dx = network.backward() x -= learning_rate * dx x_test = 0.005 * x_test + 0.005 * x 7.3 Regulation用于提升单个学习器的表现Idea 1: L1, L2, Elastic Idea 2: 对于NN：Dropout即在正向传播过程中，对于每层激活函数随机选取一些神经元置零，一般使用在全连接层。测试时引入Dropout不好，会改变预测结果，考虑对训练的不同情况做平均Inverted Dropout: test时消除了p，测试时更加高效 Idea 3: Batch Normalization使用最多 Idea 4: Data augmentation将原始数据做一定的变换，标签不变。例如对于原始图像，随机地加个滤镜或者翻转旋转或者局部裁剪，标签仍设为猫，增加样本数 Idea 5: DropConnect即在正向传播过程中，对于每层权重矩阵置零 Idea 6: fractional max pooling Idea 7: Stochastic Depth随机消除一些层，直接连向下一层 7.4 Transfer Learning处理过拟合问题，一种方法是使用正则化，一种方法是使用迁移学习 在一个已知的大训练集上训练的一个较好的模型，如Imagenet 对于小的数据集，对不需要的类别的权重进行固定，训练那些需要的类别对应的权重。例如Imagenet中有3000类，需要进行10种狗的训练，W=[409610]-d，则将另外[40962990]-d固定。 对于更大的数据集，可能只需要微调，所以对于这个问题，将learning_rate调低，再次训练即可。 Lecture 8: Deep Learning SoftwareComputational GraphsNumpy VS TensorFlow VS PyTorch TensorFlow: Neural NetworkRunning example: Train a two-layer ReLU network on random data with L2 loss1234567891011121314151617181920212223242526272829303132333435import numpy as npimport tensorflow as tfimport matplotlib.pyplot as pltN, D, H = 64, 1000, 100x = tf.placeholder(tf.float32, shape=(N, D))y = tf.placeholder(tf.float32, shape=(N, D))w1 = tf.placeholder(tf.float32, shape=(D, H))w2 = tf.placeholder(tf.float32, shape=(H, D))h = tf.maximum(tf.matmul(x, w1), 0)y_pred = tf.matmul(h, w2)diff = y_pred - yloss = tf.reduce_mean(tf.reduce_sum(diff ** 2, axis=1))grad_w1, grad_w2 = tf.gradients(loss, [w1, w2])with tf.Session() as sess: values = &#123; x: np.random.randn(N, D), w1: np.random.randn(D, H), w2: np.random.randn(H, D), y: np.random.randn(N, D), &#125; learning_rate = 1e-5 t_list = [] loss_val_list = [] for t in range(50): out = sess.run([loss, grad_w1, grad_w2], feed_dict=values) loss_val, grad_w1_val, grad_w2_val = out values[w1] -= learning_rate * grad_w1_val values[w2] -= learning_rate * grad_w2_val t_list.append(t) loss_val_list.append(loss_val) plt.scatter(t_list, loss_val_list) plt.show() result: 问题1：权重矩阵每次都在TensorFlow和Numpy中复制，导致资源浪费解决方案：将placeholder改为Variable1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport tensorflow as tfimport matplotlib.pyplot as pltN, D, H = 64, 1000, 100x = tf.placeholder(tf.float32, shape=(N, D))y = tf.placeholder(tf.float32, shape=(N, D))# Change w1 and w2 from placeholder to Variablew1 = tf.Variable(tf.random_normal((D, H)))w2 = tf.Variable(tf.random_normal((H, D)))h = tf.maximum(tf.matmul(x, w1), 0)y_pred = tf.matmul(h, w2)diff = y_pred - yloss = tf.reduce_mean(tf.reduce_sum(diff ** 2, axis=1))grad_w1, grad_w2 = tf.gradients(loss, [w1, w2])# update w1 and w2 as part of the graphlearning_rate = 1e-5new_w1 = w1.assign(w1 - learning_rate * grad_w1)new_w2 = w2.assign(w2 - learning_rate * grad_w2)updates = tf.group(new_w1, new_w2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) values = &#123; x: np.random.randn(N, D), y: np.random.randn(N, D), &#125; t_list = [] loss_val_list = [] for t in range(50): loss_val, _ = sess.run([loss, updates], feed_dict=values) t_list.append(t) loss_val_list.append(loss_val) plt.scatter(t_list, loss_val_list) plt.show() result: PytorchComputational Graphs: static vs dynamic 静态在后续可以多次更新，寻找最优值 (static) 一旦建立好，可以序列化，不需要每次都重新建立 (static) 有时可以让代码更简洁(dynamic)TensorFlow: static; PyTorch: dynamic Dynamic Graph Applications Recurrent Networks Recursive Networks Modular Networks CaffeLecture 9: CNN ArchitecturesAlexNetVGGGoogLeNetResNetLecture 10: RNNLecture 11: Applications11.1 分割Semantic Segmentation Idea: Fully ConvolutionalSemantic Segmentation Idea: Fully Convolutional]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习训练营|任务清单]]></title>
    <url>%2F2018%2F09%2F23%2Ftraining-camp-machine-learning-task-list%2F</url>
    <content type="text"><![CDATA[第一阶段 08.16-08.26 LR √08.16 √ 语音直播：机器学习的应用及理论分类 [附件] 08.17 √ 视频直播：达观杯文本智能处理赛解析 任务1：理解已给的比赛代码，即每一行代码是干什么用的 08.18-08.20 √ 任务1：西瓜书3.1/3.2/3.3章节学习 作业1：描述对数几率回归算法的过程 08.21-08.22 √ 任务1：西瓜书3.3节的一个扩展内容：softmax回归和3.6节学习 [参考链接] 08.19-08.26 √ 作业1：比赛提交 作业2：LogisticRegression 的 parameters 的每个参数的意义 第二阶段 08.28-09.11 SVM&amp;NB ×08.28-08.30 √ 任务1：西瓜书7.3/7.1/7.2章节学习 08.31-09.01 × 任务1：实验-sklearn-user guide 1.9 [参考链接] 09.02-09.03 √ 任务1：西瓜书6.1/6.2/6.3 视频直播：达观杯之文本分类任务解析与代码使用 [附件] 09.04-09.06 √ 任务1：西瓜书6.4/6.5 09.07-09.09 × 任务1：实验-sklearn-user guide 1.4 [参考链接] 08.28-09.11 × 作业1：描述SVC算法过程 作业2：描述朴素贝叶斯算法过程 作业3：用朴素贝叶斯或SVM算法做比赛，看能否取得更好的效果 × 第三阶段 09.12-09.25 DT&amp;ensemble09.12-09.14 × 任务1：西瓜书4.1/4.2/4.3/4.4章节学习 × [差4.4] 作业1：用决策树算法做比赛，看看能否取得更好的效果 09.15-09.16 × 任务1：实验-sklearn-user guide 1.10 [参考链接] 09.18-09.21 × 任务1：西瓜书第八章所有内容 × 作业1：用集成学习的思想，及融合多个模型来做比赛，看能否取得更好效果 × 09.22-09.23 × 任务1：实验-sklearn-user guide 1.11 [参考链接]]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习|周志华]]></title>
    <url>%2F2018%2F09%2F21%2Fbook-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[第8章 集成学习8.1 个体与集成集成学习的一般结构是：先产生一组“个体学习器”(individual learner)，再用某种策略把他们结合起来。 若集成中只包含同种类型的个体学习器，如“决策树集成”中全是决策树，这样的集成是同质的(homogeneous)。同质集成中的个体学习器也称为“基学习器”(base learner)，相应的学习算法称为“基学习算法”(base learning algorithm)。 若集成中包含不同类型的个体学习器，如同时包含决策树和神经网络，这样的集成式异质的(heterogeneous)。异质集成中的个体学习器也称为“组件学习器”(component learner)或个体学习器。 要想获得好的集成，个体学习器应“好而不同”，即个体学习器要有一定的“准确性”(学习器不能太坏)，并且要有“多样性”(学习期间要有差异)。至少需要使用弱学习器，即泛化性能高于随即猜测的学习器，例如二分类问题精度高于50%。 考虑分类问题$y \in \{-1, +1\}$和真实函数$f$，假定基分类器的错误率为$\epsilon$，即对每个基分类器$h_i$有： P(h_i(x) \neq f(x)) = \epsilon \tag{8.1}假设集成通过简单投票法结合$T$个基分类器，若有超过半数的基分类器正确，则判定集成分类为正确，则： H(x) = sign(\sum\limits_{i=1}^{T}h_i(x)) \tag{8.2}假设基分类器的错误率相对独立，则由Hoeffding不等式可知，集成的错误率为：\begin{align}P(H(x) \neq f(x)) &amp; = \sum\limits_{k=0}^{\left \lfloor T/2 \right \rfloor} \tbinom{T}{k} (1 - \epsilon)^k \epsilon ^{T-k} \\&amp; \leq exp(-\frac{1}{2} T(1-2\epsilon)^2) \tag{8.3}\end{align}结论：随着集成分类器数目$T$的增大，集成的错误率将指数级下降，最后趋向于零。 根据个体学习器的生成方式，目前的集成学习方法大致可以分类两类：一类是个体学习器间存在强依赖关系，必须串行生成的序列化方法，代表是Boosting；另一类是个体学习器间不存在强依赖关系，可同时生成的化方并行化方法，代表是Bagging和随机森林。 8.2 BoostingBoosting族算法的工作机制类似于：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器数目达到事先指定的值$T$，最终将这$T$个基学习器进行加权融合。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编程：从入门到实践|笔记]]></title>
    <url>%2F2018%2F09%2F20%2Fbook-python%E7%BC%96%E7%A8%8B-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-EricMatthes-%E8%A2%81%E5%9B%BD%E5%BF%A0%2F</url>
    <content type="text"><![CDATA[第2章 变量和简单数据类型2.1 运行 hello_world.py 时发生的情况2.2 变量的命名和使用 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，不能以数字打头。 变量名不能包含空格，但可使用下划线来分割其中的单词。 不要将python关键字和函数名用作变量名。 变量名应既简短又具有描述性。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 2.3 字符串2.3.1 使用方法修改字符串的大小写 str.title()：首字母大写 str.upper()：全部大写 str.lower()：全部小写 2.3.2 合并(拼接)字符串 例：”hello” + “ “ + “world” 2.3.3 使用制表符或换行符来添加空白 例：print(“\tpython”) 例：print(“python\n”)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韩语学习第1课|什么是韩文？한글은 무엇인가?]]></title>
    <url>%2F2018%2F09%2F19%2Fvideo-Learn-Korean-lesson-one%2F</url>
    <content type="text"><![CDATA[韩国文字被称为韩文(한글，hangul)，是一种表音文字。(汉语是表意文字) “한글”这个名称中“한”为韩语固有词“大”的意思，“글”为韩语固有词“字”的意思，“한글”意为“大字”或“伟大的文字”。 下一篇：韩语学习第2课|单母音 ㅏㅓㅗㅜㅡㅣㅐㅔㅚㅟ 1.1 韩文的创造背景 韩国古代使用汉字表记，导致文言分离。古代唯贵族可习汉文，因此平民多文盲。 朝鲜王朝第四代王“世宗大王”深感汉字对于文化传播的不便，迫切需要完整表达本国语音的文字，所以组织发明韩文字母한글，于正统八年(1443)颁定《训民正音》。 国之语音异乎中国 与文字不相流通 故愚民有所欲言而终不得伸其情者多矣 予为此惘然 新制二十八字 预使人易习使于日用矣 —— 《训民正音》 1.2 训民正音的造字原理 当时共有28个字母，现在共有40个字母。 母音(元音)21个，子音(辅音)19个。 母音利用天地人的形象创造出来。 天·天圆 ·地·地平 ㅡ人·人直 ㅣ衍生出ㅏㅓㅗㅜㅑㅕㅛㅠ等 基本子音ㄱㄴㅅㅁㅇ是根据人的发音器官的模样创造出来的。 牙音ㄱ(像人的牙根)：衍生出ㅋ舌音ㄴ(像人的舌头)：衍生出ㄷ齿音ㅅ(像牙齿的侧面)：衍生出ㅈㅊ唇音ㅁ(像人的嘴唇)：衍生出ㅂㅍ喉音ㅠ(像人的喉咙)：衍生出ㅎ 1.3 韩文的结构 子音(辅音) + 母音(元音) [左右] ha —&gt; ㅎ+ㅏ哈 —&gt; 하 子音(辅音) + 母音(元音) + 韵尾(子音) [左右下] han —&gt; ㅎ+ㅏ+ㄴ韩 —&gt; 한 1.4 韩语的词汇 韩语词汇分为汉字词(70%)，固有词(20%)，外来词(10%)三个部分。 汉字词：源于汉字，后被融入韩国语词汇体系中，发音于汉字发音相似。 例：사회(社会) 학교(学校) 도사관(图书馆) 고향(故乡) 固有词：韩国本身具有的词汇。 例：사람(人) 눈(眼) 보다(看) 外来词：由汉语以外的其他语种融入韩国词汇，与原词读音相近的词。 例：바나나(香蕉) 버스(公共汽车) 컴퓨터(电脑) 1.5 韩语语法特点 汉语是孤立语，它的语法关系主要通过语序来体现。韩语属于粘着语，它的语法关系主要是通过附着在单词后面的助词和语尾的变化来表示的。 韩语是以动词结束的语言。与日语相同。 韩语的句子结构是：主语 + 目的语(宾语) + 叙述语(谓语) 例：나는 책을 봤차我 书 看了其中는是主格助词表示前面的是主语，는是目的语助词表示前面的是宾语，봤차中涵盖了过去式。 다음 시간에 만나요! 下节课再见！]]></content>
      <tags>
        <tag>韩语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer|笔记]]></title>
    <url>%2F2018%2F09%2F18%2Fbook-%E5%89%91%E6%8C%87offer-%E4%BD%95%E6%B5%B7%E6%B6%9B%2F</url>
    <content type="text"><![CDATA[第1章 面试的流程1.1 面试官谈面试 对于初级程序员，一般偏向考察算法和数据结构；对于高级程序员，关注专业技能和项目经验。 对公司近况，项目情况有所了解，准备好合适的问题问面试官。 1.2 面试的三种形式 电话面试 共享桌面远程面试 思考清楚再开始编码 良好的代码命名和缩进对齐习惯 能够单元测试：定义函数后立即对该函数进行全面的单元测试 现场面试 1.3 面试的三个环节 行为面试 应聘者的项目经验 简短的项目背景 完成的任务 为完成任务做了哪些工作，怎么做的 自己的贡献(具体) 常见问题 你在该项目中遇到的最大的问题是什么？你是如何解决的？ 从这个项目中你学到了什么？ 什么时候会和其他团队成员有什么样的冲突？你们是如何解决冲突的？ 应聘者掌握的技能 参与、负责、了解、熟悉、精通的区别 技术面试 基础知识扎实全面，包括编程语言、数据结构、算法等 能写出正确的、完整的、鲁棒的高质量代码 例：把一个字符串转化成整数 例：求链表中的倒数第k个节点 能思路清晰地分析、解决复杂问题 能从时间、空间复杂度两方面优化算法效率 例：求斐波那契数列使用递归会存在大量重复计算，时间复杂度$O(2^n)$；先求f(1)，f(2)，相加求得f(3)，以此类推，时间复杂度$O(n)$ 具备优秀的沟通能力、学习能力、发散思维能力等 应聘者提问 第2章 面试需要的基础知识2.1 面试官谈基础知识 面向对象的特性、构造函数、析构函数、动态绑定、内存管理 常用的设计模式、UML图2.2 编程语言]]></content>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第372题|删除链表节点 [简单]]]></title>
    <url>%2F2018%2F09%2F06%2FLintCode-0372-delete-node-in-a-linked-list%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述给定一个单链表中的一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。样例Linked list is 1-&gt;2-&gt;3-&gt;4, and given node 3, delete the node in place 1-&gt;2-&gt;4原题链接 2. 解题思路将node的值替换为node的next的值，再将node.next替换为node.next.next。即将node.next复制到node再删去node.next。 3. 参考代码1234567891011121314151617"""Definition of ListNodeclass ListNode(object): def __init__(self, val, next=None): self.val = val self.next = next"""class Solution: """ @param: node: the node in the list should be deletedt @return: nothing """ def deleteNode(self, node): node.val, node.next = node.next.val, node.next.next]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第373题|奇偶分割数组 [简单]]]></title>
    <url>%2F2018%2F09%2F06%2FLintCode-0373-partition-array-by-odd-and-even%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述分割一个整数数组，使得奇数在前偶数在后。样例给定 [1, 2, 3, 4]，返回 [1, 3, 2, 4]。挑战在原数组中完成，不使用额外空间。原题链接 2. 解题思路使用两个指针，一个从头到尾，一个从尾到头，每当发现左半边指针指向偶数，右半边指针指向奇数时将两个数调换，直到两指针汇集到数组正中间。 3. 参考代码1234567891011121314151617class Solution: """ @param: nums: an array of integers @return: nothing """ def partitionArray(self, nums): i = 0 j = len(nums) - 1 while(i &lt; j): if nums[i] % 2 == 1: i += 1 if nums[j] % 2 == 0: j -= 1 if i &lt; j: tmp = nums[i] nums[i] = nums[j] nums[j] = tmp]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第38题|搜索二维矩阵Ⅱ [中等]]]></title>
    <url>%2F2018%2F09%2F06%2FLintCode-0038-search-a-2d-matrix-ii%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述写出一个高效的算法来搜索m×n矩阵中的值，返回这个值出现的次数。这个矩阵具有以下特性： 每行中的整数从左到右是排序的。 每一列的整数从上到下是排序的。 在每一行或每一列中没有重复的整数。样例考虑下列矩阵：[[1, 3, 5, 7],[2, 4, 7, 8],[3, 5, 9, 10]]给出target = 3，返回 2挑战要求O(m+n)时间复杂度和O(1)额外空间原题链接 2. 解题思路从矩阵右上角开始查找，若当前数大于target，则向左一格；若当前数小于target，则向下一格；若当前数等于target，则向左下一格。 3. 参考代码1234567891011121314151617181920212223class Solution: """ @param matrix: A list of lists of integers @param target: An integer you want to search in matrix @return: An integer indicate the total occurrence of target in the given matrix """ def searchMatrix(self, matrix, target): if matrix == []: return 0 max_m = len(matrix) - 1 m = 0 n = len(matrix[0]) - 1 count = 0 while m &lt;= max_m and n &gt;= 0: if matrix[m][n] == target: count = count + 1 m = m + 1 n = n - 1 elif matrix[m][n] &gt; target: n = n - 1 elif matrix[m][n] &lt; target: m = m + 1 return count]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第3题|统计数字 [中等]]]></title>
    <url>%2F2018%2F09%2F06%2FLintCode-0003-digit-counts%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述计算数字k在0到n中的出现的次数，k可能是0~9的一个值样例例如n=12，k=1，在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]，我们发现1出现了5次 (1, 10, 11, 12)原题链接 2. 解题思路把数的集合转化成字符串，再从字符串中找k 3. 参考代码1234567891011class Solution: class Solution: """ @param k: An integer @param n: An integer @return: An integer denote the count of digit k in 1..n """ def digitCounts(self, k, n): nums = [str(i) for i in range(n + 1)] s = "".join(nums) return s.count(str(k))]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第40题|用栈实现队列 [中等]]]></title>
    <url>%2F2018%2F09%2F05%2FLintCode-0040-implement-queue-by-two-stacks%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述正如标题所述，你需要使用两个栈来实现队列的一些操作。队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。pop和top方法都应该返回第一个元素的值。样例比如push(1), pop(), push(2), push(3), top(), pop()，你应该返回1，2和2。挑战仅使用两个栈来实现它，不使用任何其他数据结构，push，pop 和 top的复杂度都应该是均摊O(1)的。原题链接 2. 解题思路 栈与队列的相同点 都是线性结构。 插入操作都是限定在表尾进行。 都可以通过顺序结构和链式结构实现。 插入与删除的时间复杂度都是O(1)，在空间复杂度上两者也一样。 多链栈和多链队列的管理模式可以相同。栈与队列的不同点 栈是先进后出“LIFO”，队列是先进先出“FIFO”。 删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。 应用场景不同，常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。 顺序栈能够实现多栈空间共享，而顺序队列不能。 使用一个栈作为push列表，表示队列中的元素从尾到头的排列形式。使用一个栈作为pop列表，表示队列中的元素从头到尾的排列形式。当pop列表为空而此时需要pop时，把push列表中的所有元素append到pop列表中。 例子对于push(1), pop(), push(2), push(3), top(), pop()push(1)：stack1 = [1], stack2 = []pop()：stack1 = [], stack2 = [1] =&gt; stack2 = []push(2)：stack1 = [2], stack2 = []push(3)：stack1 = [2, 3], stack2 = []top()：stack1 = [], stack2 = [3, 2]pop()：stack1 = [], stack2 = [3] 3. 参考代码代码112345678910111213141516171819202122232425262728293031323334353637383940414243class MyQueue: def __init__(self): self.stack1 = [] self.stack2 = [] """ @param: element: An integer @return: nothing """ def push(self, element): if self.stack1: self.stack1.append(element) else: while self.stack2: self.stack1.append(self.stack2.pop()) self.stack1.append(element) """ @return: An integer """ def pop(self): if self.stack2: return self.stack2.pop() elif self.stack1: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() else: return None """ @return: An integer """ def top(self): if self.stack2: return self.stack2[-1] elif self.stack1: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] else: return None 代码2123456789101112131415161718192021222324252627282930class MyQueue: def __init__(self): self.stack1 = [] self.stack2 = [] """ @param: element: An integer @return: nothing """ def push(self, element): self.stack1.append(element) """ @return: An integer """ def pop(self): if len(self.stack2) == 0: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() """ @return: An integer """ def top(self): if len(self.stack2) == 0: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1]]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第73题|前序遍历和中序遍历树构造二叉树 [中等]]]></title>
    <url>%2F2018%2F09%2F02%2FLintCode-0073-construct-binary-tree-from-preorder-and-inorder-traversal%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述根据前序遍历和中序遍历树构造二叉树。样例给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树:&nbsp;&nbsp;2&nbsp;/ \1&nbsp;&nbsp;3原题链接 2. 解题思路 二叉树的遍历 前序遍历(根-左-右) 中序遍历(左-根-右) 后序遍历(左-右-根) 前序遍历的第一个点一定是树的根节点，对应中序遍历的中间一个点，假设在位置i。这个点左侧的所有点均属于根的左子树，右侧的点均属于根的右子树。每次取前序遍历[1:i+1]和中序遍历[:i]对应于左子树，取前序遍历[i+1:]和中序遍历[i+1:]对应于右子树，递归继续以上过程。 3. 参考代码12345678910111213141516171819202122232425"""Definition of TreeNode:class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, None"""class Solution: """ @param inorder: A list of integers that inorder traversal of a tree @param postorder: A list of integers that postorder traversal of a tree @return: Root of a tree """ def buildTree(self, preorder, inorder): if len(preorder) == 0: return None elif len(preorder) == 1: return TreeNode(preorder[0]) else: node = TreeNode(preorder[0]) pos = inorder.index(preorder[0]) node.left = self.buildTree(preorder[1 : pos + 1], inorder[: pos]) node.right = self.buildTree(preorder[pos + 1 :], inorder[pos + 1 :]) return node]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第159题|寻找旋转排序数组中的最小值 [中等]]]></title>
    <url>%2F2018%2F09%2F02%2FLintCode-0159-find-minimum-in-rotated-sorted-array%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述假设一个旋转排序的数组其起始位置是未知的 (比如0 1 2 4 5 6 7 可能变成是4 5 6 7 0 1 2)。你需要找到其中最小的元素。你可以假设数组中不存在重复的元素。样例给出[4,5,6,7,0,1,2] 返回 0原题链接 2. 解题思路一个非减排序数组经过旋转后被分裂成了两个非减排序数组。左侧数组中的任意数均大于右侧数组中的所有数。断层的左边即全局最大数，右边即全局最小数。 思路1从数组开始位置开始遍历，直到某一刻nums[i]&gt;nums[i+1]，此时存在断层，nums[i+1]即为全局最小数。若直到数组遍历完nums[i]&lt;=nums[i+1]均成立，则nums[0]为全局最小数。时间复杂度为$O(n)$。 思路2采用二分查找，若中间点大于首位元素，则最小数在右半数组；若中间点小于等于队尾元素，则最小数在左半数组。如此递归查找，当首尾元素紧挨时，尾元素即为全局最小值。时间复杂度为$O(\log n)$。 3. 参考代码代码112345678910class Solution: """ @param nums: a rotated sorted array @return: the minimum number in the array """ def findMin(self, nums): for i in range(0, len(nums)-1): if nums[i] &gt; nums[i+1]: return nums[i+1] return nums[0] 代码21234567891011121314151617class Solution: """ @param nums: a rotated sorted array @return: the minimum number in the array """ def findMin(self, nums): left = 0 right = len(nums) - 1 if nums[left] &lt; nums[right]: return nums[0] while right - left &gt; 1: mid = int((left + right) / 2) if nums[mid] &gt;= nums[left]: left = mid elif nums[mid] &lt;= nums[right]: right = mid return nums[right]]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第35题|翻转链表 [简单]]]></title>
    <url>%2F2018%2F09%2F02%2FLintCode-0035-reverse-linked-list%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述翻转一个链表样例给出一个链表1-&gt;2-&gt;3-&gt;null，这个翻转后的链表为3-&gt;2-&gt;1-&gt;null挑战在原地一次翻转完成原题链接 2. 解题思路设置一个指针pre指向翻转后的链表表头，初始指向null。每次对于原链表的表头head，使head.next指向pre，pre指向head，head指向head.next。 例子对于1-&gt;2-&gt;3-&gt;null初始：head.val = 1, head.next.val = 2, pre = None第一次迭代：head.next.val = None, pre.val = 1, head.val = 2, pre为表头的链表：1-&gt;null第二次迭代: head.next.val = 1, pre.val = 2, head.val = 3, pre为表头的链表：2-&gt;1-&gt;null第三次迭代: head.next.val = 2, pre.val = 3, head.val = None, pre为表头的链表：3-&gt;2-&gt;1-&gt;null 3. 参考代码1234567891011121314151617181920"""Definition of ListNodeclass ListNode(object): def __init__(self, val, next=None): self.val = val self.next = next"""class Solution: """ @param head: n @return: The new head of reversed linked list. """ def reverse(self, head): pre = None while head: head.next, pre, head = pre, head, head.next return pre]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第6题|合并排序数组Ⅱ [简单]]]></title>
    <url>%2F2018%2F09%2F02%2FLintCode-0006-merge-two-sorted-arrays%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述合并两个排序的整数数组A和B变成一个新的数组。样例给出A=[1,2,3,4]，B=[2,4,5,6]，返回 [1,2,2,3,4,4,5,6]挑战你能否优化你的算法，如果其中一个数组很大而另一个数组很小？原题链接 2. 解题思路设置两个指针分别指向两个数组的首位，每次将当前指针指向的两个数字比较，将较小的插入新数组，并将其所在数组指针后移一位。直到其中一个数组所有数字均已插入新数组，则将另一个数组的所有剩余项一起插入新数组。 3. 参考代码1234567891011121314151617181920212223242526272829class Solution: """ @param A: sorted integer array A @param B: sorted integer array B @return: A new sorted integer array """ def mergeSortedArray(self, A, B): C = [] len_a = len(A) len_b = len(B) i = 0 j = 0 while i &lt; len_a and j &lt; len_b: if A[i] &lt; B[j]: C.append(A[i]) i = i + 1 elif A[i] &gt; B[j]: C.append(B[j]) j = j + 1 else: C.append(A[i]) C.append(B[j]) i = i + 1 j = j + 1 if i &lt; len_a: C.extend(A[i:]) if j &lt; len_b: C.extend(B[j:]) return C]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode第2题|尾部的零 [简单]]]></title>
    <url>%2F2018%2F09%2F02%2FLintCode-0002-trailing-zeros%2F</url>
    <content type="text"><![CDATA[1. 问题介绍 描述设计一个算法，计算出n阶乘中尾部零的个数样例11! = 39916800，因此应该返回 2挑战O(logN)的时间复杂度原题链接 2. 解题思路对$1 \times 2 \times \dots \times N$进行因式分解，结尾的每一个0都代表了含有一个因子10。而所有的因子10一定是由5与偶数相乘而得，即必定含有质因子2和5。由于阶乘展开式中2的个数远多于5的个数，因而计算5的个数即可。 3. 参考代码123456789101112class Solution: """ @param: n: An integer @return: An integer, denote the number of trailing zeros in n! """ def trailingZeros(self, n): count = 0 tmp = int(n / 5) while tmp != 0: count += tmp tmp = int(tmp / 5) return count]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode|归档]]></title>
    <url>%2F2018%2F09%2F01%2FLintCode-all%2F</url>
    <content type="text"><![CDATA[LintCode第2题|尾部的零 [简单]LintCode第3题|统计数字 [中等]LintCode第6题|合并排序数组Ⅱ [简单]LintCode第35题|翻转链表 [简单]LintCode第38题|搜索二维矩阵Ⅱ [中等]LintCode第40题|用栈实现队列 [中等]LintCode第73题|前序遍历和中序遍历树构造二叉树 [中等][LintCode第140题|快速幂 [中等]]LintCode第159题|寻找旋转排序数组中的最小值 [中等]LintCode第174题|删除链表中倒数第n个节点 [简单][LintCode第371题|用递归打印数字 [中等]]LintCode第372题|删除链表节点 [简单][LintCode第245题|子树 [中等]]LintCode第373题|奇偶分割数组 [简单]]]></content>
      <tags>
        <tag>LintCode</tag>
        <tag>归档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大历史|黄仁宇]]></title>
    <url>%2F2018%2F07%2F14%2Fbook-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%8E%86%E5%8F%B2-%E9%BB%84%E4%BB%81%E5%AE%87%2F</url>
    <content type="text"><![CDATA[第零章 为什么称为“中国大历史” 徭役税收：里甲、均徭、驿传、民壮 官僚系统里以仪礼代替行政，维持各品级文官的协同和谐，不顾及各区内经济因素之公平而自由的交换。 《二十四史》—《食货志》 《资治通鉴》 Comprehensive Mirror for Aid In Government 第一章 西安与黄土地带 现今考古仍旧无法证明夏代一千的历史记载是否属实，而商朝又甲骨文和殷墟遗址佐证。 西安—华清池—杨贵妃—唐玄宗—天宝十四年，安禄山“清君侧”起兵谋反，于四川马嵬驿，杨贵妃被缢。 《长恨歌》唐·白居易汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。春寒赐浴华清池，温泉水滑洗凝脂。侍儿扶起娇无力，始是新承恩泽时。云鬓花颜金步摇，芙蓉帐暖度春宵。春宵苦短日高起，从此君王不早朝。承欢侍宴无闲暇，春从春游夜专夜。后宫佳丽三千人，三千宠爱在一身。金屋妆成娇侍夜，玉楼宴罢醉和春。姊妹弟兄皆列土，可怜光彩生门户。遂令天下父母心，不重生男重生女。骊宫高处入青云，仙乐风飘处处闻。缓歌慢舞凝丝竹，尽日君王看不足。渔阳鼙鼓动地来，惊破霓裳羽衣曲。九重城阙烟尘生，千乘万骑西南行。翠华摇摇行复止，西出都门百余里。六军不发无奈何，宛转蛾眉马前死。花钿委地无人收，翠翘金雀玉搔头。君王掩面救不得，回看血泪相和流。黄埃散漫风萧索，云栈萦纡登剑阁。峨嵋山下少人行，旌旗无光日色薄。蜀江水碧蜀山青，圣主朝朝暮暮情。行宫见月伤心色，夜雨闻铃肠断声。天旋地转回龙驭，到此踌躇不能去。马嵬坡下泥土中，不见玉颜空死处。君臣相顾尽沾衣，东望都门信马归。归来池苑皆依旧，太液芙蓉未央柳。芙蓉如面柳如眉，对此如何不泪垂。春风桃李花开日，秋雨梧桐叶落时。西宫南内多秋草，落叶满阶红不扫。梨园弟子白发新，椒房阿监青娥老。夕殿萤飞思悄然，孤灯挑尽未成眠。迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共。悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。为感君王辗转思，遂教方士殷勤觅。排空驭气奔如电，升天入地求之遍。上穷碧落下黄泉，两处茫茫皆不见。忽闻海上有仙山，山在虚无缥渺间。楼阁玲珑五云起，其中绰约多仙子。中有一人字太真，雪肤花貌参差是。金阙西厢叩玉扃，转教小玉报双成。闻道汉家天子使，九华帐里梦魂惊。春风桃李花开日，秋雨梧桐叶落时。西宫南内多秋草，落叶满阶红不扫。梨园弟子白发新，椒房阿监青娥老。夕殿萤飞思悄然，孤灯挑尽未成眠。迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共。悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。为感君王辗转思，遂教方士殷勤觅。排空驭气奔如电，升天入地求之遍。上穷碧落下黄泉，两处茫茫皆不见。忽闻海上有仙山，山在虚无缥渺间。楼阁玲珑五云起，其中绰约多仙子。中有一人字太真，雪肤花貌参差是。金阙西厢叩玉扃，转教小玉报双成。闻道汉家天子使，九华帐里梦魂惊。揽衣推枕起徘徊，珠箔银屏迤逦开。云鬓半偏新睡觉，花冠不整下堂来。风吹仙袂飘飖举，犹似霓裳羽衣舞。玉容寂寞泪阑干，梨花一枝春带雨。含情凝睇谢君王，一别音容两渺茫。昭阳殿里恩爱绝，蓬莱宫中日月长。回头下望人寰处，不见长安见尘雾。惟将旧物表深情，钿合金钗寄将去。钗留一股合一扇，钗擘黄金合分钿。但教心似金钿坚，天上人间会相见。临别殷勤重寄词，词中有誓两心知。七月七日长生殿，夜半无人私语时。在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。 西安事变—蒋介石蒙难 中国新石器时代的遗址最初出现于公元前4000年—碳14放射性技术 商朝—公元前约1600年—遗址位于今河南省，历史上称为“关东” 人祭 国王的陵墓由上而下掘土而成，上端的坑大，越至下端愈小。国王的陪葬品有战车和马匹，殉葬的人被斩首，头颅和躯体整齐地排列。出殡时有繁缛的礼节。 甲骨文：象形(日月)、会意(东祭)、形声(亦来)—日在树后升起是为东，双手执鸡放在樽俎内为祭。 第二章 亚圣和始皇 武王伐纣建立周朝，以封建方式制定了一种合乎当时农业扩张的统治形态，又以宗法制度使封建统治更加稳固。 亚圣—孟子—生于山东之邹—劳心者治人，劳力者治于人—乐岁终身饱，凶年免于死亡—五十可以衣帛，七十可以食肉。 中国古代史里的日期只有在公元前841年之后才能确定无误。因为自此以后，古书里提及天候星象的变化可以和外间的记录相对照。之前的日期带有推算性质。 周人尚鬼，认为万物有灵。 周公—文王之子，武王之弟—封建—将封建制与宗法制结为一体—耕地井田制 公元前771年，国度西安被入侵的戎人毁灭，国王被杀，王子东迁，史称东周，东周又被分为春秋时代和战国时代。如此称呼是源于《春秋》《战国》两本书。 道家—圣人不死，大盗不止—崇信宇宙间的一元组织，回归原始的简朴 第三章 土壤、风向和雨量 易于耕作的纤细黄土、能带来丰沛雨量的季候风，时而润泽大地时而泛滥成灾的黄河，是影响中国命运的三大因素。它们直接或间接地促使中国要采取中央集权式的、农业形态的官僚体系。 杨朱—虽拔一毛以利天下不为也—各人遵循自己的私利观以行事 第四章 兵马俑的幕后 全面改革—贵族被废为平民，官吏按能力任职，井田制度遗体取消，土地得以自由买卖，土地税按亩征收，士兵按征兵入伍—重农抑商—中央集权制 废六国，全国划分为三十六郡，每郡守尉监各一—标准化文字、度量衡—焚书坑儒。 秦王有一次因风受阻而不能渡湘水，归罪湘君女神作祟，于是遣发三千囚徒去砍伐山上的树木以资报复 以黑色代表帝国之色彩 预定每天必须过目的书简以重量作进度，不到目标不得休息 秦始皇墓不少匠役由于熟悉内情过多而被活埋在陵寝之内 兵马俑的艺术与技巧之所以不能持续，可以用缺乏社会的推动力来解释。米开朗基罗需要教廷雇佣才能发展他的天才，鲁本斯靠替各国国王画画像而生活优裕。秦国的无名艺术家的不幸之处在于他们的作品是集体完成的，只能贡献于一个君主之前。 第五章 第一帝国：树立楷模 汉武帝对内罢黜百家独尊儒术，奠下中央集权官僚体制运作的理论与方法，对外则连年发兵征讨匈奴，开拓四裔，使大汉声威远播，国势达于顶峰。 财政短绌，外戚干政 布衣卿相—萧何曹参曾任县级小官僚，樊哙曾为屠夫，黥布彭越曾为盗 汉初期帝国跨地过广，不能全部由中央集体管制，遂采取“斑马式”的省级结构—郡县+王侯—帝裔里的近亲为王，功臣中的卿相为侯 五行金木水火土—五方东西南北中—五色白青黑赤黄—五音宫商角徵羽—五德仁义礼 木=青色，为木叶萌芽之色火=赤色，为篝火燃烧之色土=黄色，为地气勃发之色金=白色，为金属光泽之色水=黑色，为深渊无垠之色 《易经》军事扩张—战—商、税—苛捐杂税、剥削百姓 李广—卫青(皇后卫子夫之异母弟)—霍去病(皇后外甥)—霍光(霍去病异母弟)—桑弘羊 王莽改革，刘秀杀之，建东汉 第六章 名士成为军阀 鼓吹天人合一、自然和谐 武帝创立太学 西汉张骞通西域，后汉班超通西域 冬至—日晷—阴阳交替之日 武帝“察举”“征辟”—举孝廉—贤良方正之士 [矛盾：政府与平民；中央政府与地方政府；天与人] 官渡之战—曹操—袁绍 第七章 长期分裂的局面 五胡乱华—藏族及阿尔泰语体系；原始蒙古人和初期突厥语系 魏擅骑兵，吴擅水师(公元三世纪) 第八章 历史向侧面进出 佛教大为盛行 “若天命在吾，吾其为周文王矣。” ——曹操 — 西伯向商称臣，其子武王取商代之；曹操称臣，其子曹丕宣布魏朝成立；司马家亦如法炮制 “国家本是精神产物。” ——钱穆《国史大纲》 在中国的戏曲里，曹操的面谱全部涂白，状如墙壁，以显示其谲诈，只有眼角稍沾墨笔，表现他机警应变的能力。 中国戏曲始于唐，取得市井间娱乐地位则于宋 “妾与陛下男女虽殊，俱托体先帝，陛下六宫万数，妾惟驸马一人，事大不均！” ——山阴公主楚玉 司马衷在位内战爆发，戎狄交兵。随从报告“天下荒馑，百姓饿死”，他闻之而曰：“何不食肉糜？” 南朝齐王“东昏侯”萧宝卷凿金为莲花贴地，令潘妃行其上，称“此步步生莲花也” 《西塞山怀古》唐·刘禹锡王濬楼船下益州，金陵王气黯然收。千寻铁锁沉江底，一片降幡出石头。人世几回伤往事，山形依旧枕寒流。今逢四海为家日，故垒萧萧芦荻秋。 第九章 统一的途径 拓跋氏建立北魏政权，直接征税于农户 颁布均田令 以五家为邻，五邻为里，五里为党，指派邻里党长。以一夫一妇为一“床”，责成出米两石，布一匹 第十章 第二帝国：已有突破，但未竟事功 [未完待续]]]></content>
      <tags>
        <tag>阅读札记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小技巧]]></title>
    <url>%2F2018%2F01%2F01%2Fplug%2F</url>
    <content type="text"><![CDATA[H5视频加速播放document.getElementById(&#39;html5player_html5_api&#39;).playbackRate=2.0 抖音、快手等视频解析http://douyin.iiilab.com/]]></content>
      <tags>
        <tag>归档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018年]]></title>
    <url>%2F2018%2F01%2F01%2Fmy-2018%2F</url>
    <content type="text"><![CDATA[私密文档，请输入密码。 Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>归档</tag>
      </tags>
  </entry>
</search>
